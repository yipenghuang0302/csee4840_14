\section{Software Prototype}
Our software prototyping has two goals. The first goal is to verify we 
understand and can translate the algorithm to hardware. The second 
purpose of our prototype is a way of verifying results from our hardware.
We found an open source C++ project on github.com which computes the 
incremental angle movements for a given robot to reach a target position 
given a beginning position using three different algorithms 
\cite{ik_cpp_library}. The algorithms being used in the open source project 
were all ones we had been exploring to implement in hardware. The code was 
organized and very clean. It was perfect for us to grasp how the Jacobian 
Transpose, Jacobian Pseudo Inverse, and Damped Least Squares algorithms 
worked in practice since our only source had been higher level papers. This 
project also covers our second need, for a way to verify results from our 
hardware. The fact that the project wasn't implemented by us gives it 
credibility; it would be easy to implement the algorithm incorrectly in 
software and then in hardware and not realize the original software was 
wrong. 

Along with using this open source project we implemented a smaller 
prototype that reflects the structures in our hardware and only 
uses the one algorithm we are using. By creating this second software 
project we were able to play around with structures to determine what
would work best. For example, we were able to modify the code
and see how fixed point or integer math 
worked instead of floating point. We also used this project to test different 
computational methods for sin and cos. It was important to test how the 
accuracy of our algorithm changed if we changed computational methods like 
the ones mentioned above. Editing was much easier to do in software 
and less time consuming.

Since parsing XML documents in software isn't really an important part of 
learning how to write embedded systems we decided to use part of the 
open source C++ project to parse the XML robot configuration files to 
retrieve the original joint positions and the joint types. The software 
from the cpp-inverse-kinematics-library parses a given XML file and 
gives the resulting joint information to software we have created. Our 
software then obtains a target position from the user and, given the 
target information and the joint configurations, it computes the 
next angle positions using our FPGA hardware component. 
